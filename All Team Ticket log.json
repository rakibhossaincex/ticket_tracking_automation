{
    "nodes": [
        {
            "parameters": {
                "mode": "runOnceForEachItem",
                "jsCode": "// ALL TEAM TICKET LOG - Enhanced with Product Type, Category-based SLA, Working Hours\n// Date range: Tickets RESOLVED in the last 5 days\n\n// Dynamic: Calculate 5 days ago from now\nconst FIVE_DAYS_SECONDS = 5 * 24 * 60 * 60;\nconst NOW_UNIX = Math.floor(Date.now() / 1000);\nconst START_UNIX = NOW_UNIX - FIVE_DAYS_SECONDS;\n\n// TEAM NAMES TO TRACK (for Yes/No columns)\nconst TRACKED_TEAMS = [\n  \"Pro Solutions Task Force\",\n  \"CEx Reversal\",\n  \"Ticket Dependencies\",\n  \"Payments and Treasury\",\n  \"GB Email Communication\",\n  \"Tech Team\",\n  \"Business Operations\",\n  \"Platform Operations\",\n  \"Case Resolution\"\n];\n\n// CEx Group teams (always 1H SLA, no working hours logic)\nconst CEX_GROUP = [\"Pro Solutions Task Force\", \"CEx Reversal\", \"Ticket Dependencies\"];\n\n// Team code mapping for SLA lookup\nfunction getTeamCode(teamName) {\n  const tn = (teamName || \"\").toLowerCase();\n  if (tn.includes(\"pro solutions\") || tn.includes(\"cex reversal\") || tn.includes(\"ticket dependencies\")) return \"CEx\";\n  if (tn.includes(\"business operations\")) return \"BO\";\n  if (tn.includes(\"payments\") || tn.includes(\"treasury\") || tn.includes(\"gb email\")) return \"PT\";\n  if (tn.includes(\"platform operations\")) return \"PO\";\n  if (tn.includes(\"tech team\")) return \"TT\";\n  if (tn.includes(\"case resolution\")) return \"CR\";\n  return \"\";\n}\n\n// Team working hours (GMT+6)\nconst TEAM_WORKING_HOURS = {\n  \"CEx\": { start: 0, end: 24 }, // 24/7 as requested\n  \"PT\": { start: 9, end: 18 },\n  \"TT\": { start: 9, end: 18 },\n  \"PO\": { start: 8.5, end: 17.5 },\n  \"CR\": { start: 8.5, end: 17.5 },\n  \"BO\": { start: 8.5, end: 17.5 }\n};\n\n// SLA limits by team code (in hours)\nconst SLA_LIMITS = {\n  \"CEx\": { weekdayOffice: 1, weekdayAfter: 1, weekendOffice: 1, weekendAfter: 1 },\n  \"BO\": { weekdayOffice: 12, weekdayAfter: 24, weekendOffice: 12, weekendAfter: 24 },\n  \"PT\": { weekdayOffice: 12, weekdayAfter: 12, weekendOffice: 24, weekendAfter: 24 },\n  \"PO\": { weekdayOffice: 3, weekdayAfter: 18, weekendOffice: 24, weekendAfter: 24 },\n  \"TT\": { weekdayOffice: 8, weekdayAfter: 20, weekendOffice: 72, weekendAfter: 72 },\n  \"CR\": { weekdayOffice: 3, weekdayAfter: 17, weekendOffice: 54, weekendAfter: 54 }\n};\n\nfunction stripHtml(html) {\n  if (!html) return \"\";\n  return String(html)\n    .replace(/<br\\s*\\/?>/gi, \"\\n\")\n    .replace(/<\\/p>/gi, \"\\n\")\n    .replace(/<[^>]+>/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction toISODate(unixSeconds) {\n  const n = (typeof unixSeconds === \"number\") ? unixSeconds : parseInt(unixSeconds, 10);\n  if (!n || Number.isNaN(n)) return \"\";\n  const gmt6Epoch = (n + 21600) * 1000;\n  return new Date(gmt6Epoch).toISOString().slice(0, 10);\n}\n\nfunction norm(s) { return (s || \"\").toString().trim().toLowerCase(); }\n\nfunction getAuthor(part) {\n  const a = part?.author || part?.created_by || part?.creator || {};\n  return {\n    id: a?.id ? String(a.id) : \"\",\n    name: a?.name || \"\",\n    email: a?.email || \"\",\n    type: a?.type || \"\"\n  };\n}\n\nfunction formatDuration(seconds) {\n  if (!seconds || seconds < 0) return \"\";\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  let result = \"\";\n  if (days > 0) result += days + \"d \";\n  if (hours > 0) result += hours + \"h \";\n  if (minutes > 0 || result === \"\") result += minutes + \"m\";\n  return result.trim();\n}\n\nfunction isWithinWorkingHours(unixTimestamp, teamCode) {\n  if (!unixTimestamp || !teamCode) return true;\n  const hours = TEAM_WORKING_HOURS[teamCode];\n  if (!hours) return true;\n  const gmt6Ms = (unixTimestamp + 21600) * 1000;\n  const date = new Date(gmt6Ms);\n  const hour = date.getUTCHours() + date.getUTCMinutes() / 60;\n  return hour >= hours.start && hour < hours.end;\n}\n\nfunction isWeekend(unixTimestamp) {\n  if (!unixTimestamp) return false;\n  const gmt6Ms = (unixTimestamp + 21600) * 1000;\n  const date = new Date(gmt6Ms);\n  const day = date.getUTCDay();\n  return day === 0 || day === 6;\n}\n\nfunction getSlaLimitHours(teamCode, isWeekendDay, isDuringOfficeHours) {\n  const limits = SLA_LIMITS[teamCode];\n  if (!limits) return 24;\n  if (isWeekendDay) {\n    return isDuringOfficeHours ? limits.weekendOffice : limits.weekendAfter;\n  } else {\n    return isDuringOfficeHours ? limits.weekdayOffice : limits.weekdayAfter;\n  }\n}\n\nconst ticket = $json || {};\n\nconst ticketDisplayId = String(ticket.ticket_id || ticket.id || \"\");\nconst ticketState = norm(ticket.ticket_state || ticket.state || \"\");\nconst ticketStateLabel = ticket.ticket_state_internal_label || ticket.ticket_state_external_label || ticket.ticket_state || \"\";\nconst isResolved = (ticketState === \"resolved\" || ticketState === \"closed\");\n\n// Extract Product Type from ticket_attributes\nlet productType = \"\";\nconst ticketAttrs = ticket.ticket_attributes || {};\nfor (const key of Object.keys(ticketAttrs)) {\n  if (key.toLowerCase().includes(\"product\") && key.toLowerCase().includes(\"type\")) {\n    productType = String(ticketAttrs[key] || \"\");\n    break;\n  }\n}\nif (!productType && ticketAttrs[\"Product Type\"]) {\n  productType = String(ticketAttrs[\"Product Type\"]);\n}\n\n// Normalize product types: CFDs -> CFD, Stellar Instant -> CFD, Futures -> Futures\nconst ptLower = productType.toLowerCase();\nif (ptLower === \"cfds\" || ptLower === \"cfd\") {\n  productType = \"CFD\";\n} else if (ptLower === \"futures\") {\n  productType = \"Futures\";\n} else if (ptLower.includes(\"stellar\") || ptLower.includes(\"instant\")) {\n  // Stellar Instant counts as CFD\n  productType = \"CFD\";\n}\n\nlet issueCategory = \"\";\nif (ticket.ticket_type && ticket.ticket_type.name) {\n  issueCategory = ticket.ticket_type.name;\n} else if (ticket.custom_attributes && ticket.custom_attributes.ticket_type) {\n  issueCategory = ticket.custom_attributes.ticket_type;\n}\nif (!issueCategory) {\n  const titleRaw = ticket?.ticket_attributes?._default_title_ || ticket?.title || ticket?.subject || \"\";\n  issueCategory = stripHtml(titleRaw);\n}\n\nconst contact = (ticket?.contacts?.contacts && ticket.contacts.contacts[0]) || (Array.isArray(ticket?.contacts) ? ticket.contacts[0] : null);\nconst contactName = contact?.name || \"\";\nconst contactEmail = contact?.email || \"\";\n\nlet parts = ticket.ticket_parts || [];\nif (!Array.isArray(parts)) {\n  const tp = ticket.ticket_parts || {};\n  parts = Array.isArray(tp.ticket_parts) ? tp.ticket_parts : (Array.isArray(tp.data) ? tp.data : []);\n}\nparts.sort((a, b) => (a?.created_at || 0) - (b?.created_at || 0));\n\nconst ticketCreatedAt = ticket.created_at || 0;\n\nlet resolvedAt = 0;\nlet resolverFromCloseEvent = \"\";\n\nif (isResolved && ticket.state_updated_at && ticket.state_updated_at > 0) {\n  resolvedAt = ticket.state_updated_at;\n}\n\nif (!resolvedAt) {\n  for (const p of parts) {\n    const currentState = norm(p?.ticket_state || p?.ticket_state_internal_label || \"\");\n    const previousState = norm(p?.previous_ticket_state || \"\");\n    const partCreatedAt = p.created_at || 0;\n    \n    const isResolvedState = currentState.includes(\"resolved\") || currentState.includes(\"closed\");\n    const wasNotResolvedBefore = previousState && !previousState.includes(\"resolved\") && !previousState.includes(\"closed\");\n    \n    if (isResolvedState && (wasNotResolvedBefore || !previousState)) {\n      if (partCreatedAt > resolvedAt) {\n        resolvedAt = partCreatedAt;\n        const au = getAuthor(p);\n        if (au.type === \"admin\" && au.name) {\n          resolverFromCloseEvent = au.name;\n        }\n      }\n    }\n    \n    const partType = norm(p?.part_type || p?.event_type || p?.type || \"\");\n    if (partType === \"close\" || partType === \"ticket_state_updated\" || \n        partType.includes(\"resolved\") || partType.includes(\"closed\")) {\n      if (isResolvedState && partCreatedAt > resolvedAt) {\n        resolvedAt = partCreatedAt;\n        const au = getAuthor(p);\n        if (au.type === \"admin\" && au.name) {\n          resolverFromCloseEvent = au.name;\n        }\n      }\n    }\n  }\n}\n\nif (!resolvedAt && isResolved) {\n  resolvedAt = ticket.created_at || 0;\n}\n\nconst resolutionTimeSeconds = (resolvedAt && ticketCreatedAt && resolvedAt > ticketCreatedAt) ? (resolvedAt - ticketCreatedAt) : 0;\nconst resolutionTime = formatDuration(resolutionTimeSeconds);\n\nconst resolvedAfterStart = resolvedAt >= START_UNIX;\nconst resolvedDateStr = toISODate(resolvedAt);\n\nlet creatorName = \"\";\nlet creatorEmail = \"\";\nconst firstAdminPart = parts.find(p => getAuthor(p).type === \"admin\");\nif (firstAdminPart) {\n  const au = getAuthor(firstAdminPart);\n  creatorName = au.name;\n  creatorEmail = au.email;\n} else {\n  creatorName = contactName;\n  creatorEmail = contactEmail;\n}\n\nconst teamsVisited = new Set();\nlet allAssignmentTimes = [];\nlet lastAdminNoteText = \"\";\nlet lastAssignedAdmin = \"\";\n\nconst currentTeamId = String(ticket.team_assignee_id || \"\");\n\nconst sd = $getWorkflowStaticData('global');\nconst teamIdToName = sd.teamIdToName || {};\n\nconst currentTeamName = teamIdToName[currentTeamId] || \"\";\nif (currentTeamName) {\n  teamsVisited.add(currentTeamName);\n}\n\nfor (const p of parts) {\n  const au = getAuthor(p);\n  const body = stripHtml(p?.body || p?.comment || p?.note || \"\");\n  const partType = norm(p?.part_type || p?.event_type || p?.type || \"\");\n  const partCreatedAt = p.created_at || 0;\n  \n  if (norm(au.type) === \"admin\" && body) lastAdminNoteText = body;\n  \n  // Requirement 2: Detect team from ANY part if it has an assigned_to team\n  const assignedTo = p.assigned_to || p.assignee || {};\n  if (assignedTo.type === \"team\") {\n    const teamId = String(assignedTo.id || \"\");\n    const teamName = assignedTo.name || teamIdToName[teamId] || \"\";\n    if (teamName) {\n      teamsVisited.add(teamName);\n    }\n  }\n\n  if (partType.includes(\"assign\") || partType === \"team_assignment\" || \n      partType === \"assignment\" || partType === \"assigned\") {\n    if (partCreatedAt > 0) {\n      allAssignmentTimes.push(partCreatedAt);\n    }\n    if (assignedTo.type === \"admin\" && assignedTo.name) {\n      lastAssignedAdmin = assignedTo.name;\n    }\n  }\n}\n\nlet handlerName = \"\";\nif (resolverFromCloseEvent) {\n  handlerName = resolverFromCloseEvent;\n} else if (lastAssignedAdmin) {\n  handlerName = lastAssignedAdmin;\n}\n\nlet agentHandleTime = \"\";\nlet agentHandleTimeSeconds = 0;\nif (resolvedAt) {\n  const validAssignments = allAssignmentTimes\n    .filter(t => t > 0 && t <= resolvedAt)\n    .sort((a, b) => b - a);\n  \n  if (validAssignments.length > 0) {\n    const lastAssignmentTime = validAssignments[0];\n    agentHandleTimeSeconds = resolvedAt - lastAssignmentTime;\n    agentHandleTime = formatDuration(agentHandleTimeSeconds);\n  } else if (ticketCreatedAt > 0) {\n    agentHandleTimeSeconds = resolvedAt - ticketCreatedAt;\n    agentHandleTime = formatDuration(agentHandleTimeSeconds);\n  }\n}\n\n// NEW SLA CALCULATION LOGIC\nconst uniqueTeamsCount = teamsVisited.size;\nconst isPSTFtoCExReversal = (\n  uniqueTeamsCount === 2 &&\n  teamsVisited.has(\"Pro Solutions Task Force\") &&\n  teamsVisited.has(\"CEx Reversal\")\n);\n\n// 1. Determine Ticket SLA applicability\nlet ticketSlaApplicable = (uniqueTeamsCount <= 1 || isPSTFtoCExReversal);\n\n// 2. Compute SLA limit hours\nlet slaLimitHours = 24; // Default fallback\nconst teamCode = getTeamCode(currentTeamName);\nconst isCExGroup = getTeamCode(currentTeamName) === \"CEx\";\n\nif (isCExGroup) {\n  slaLimitHours = 1;\n} else if (teamCode) {\n  const isWeekendDay = isWeekend(ticketCreatedAt);\n  const isDuringOfficeHours = isWithinWorkingHours(ticketCreatedAt, teamCode);\n  slaLimitHours = getSlaLimitHours(teamCode, isWeekendDay, isDuringOfficeHours);\n}\nconst slaLimitSeconds = slaLimitHours * 3600;\n\n// 3. Ticket SLA Status (Overall)\nlet ticketSlaStatus = \"N/A\";\nif (ticketSlaApplicable && resolutionTimeSeconds > 0) {\n  ticketSlaStatus = (resolutionTimeSeconds <= slaLimitSeconds) ? \"Met\" : \"Missed\";\n}\n\n// 4. Agent SLA Status (Separate)\nlet agentSlaStatus = \"N/A\";\nif (agentHandleTimeSeconds > 0) {\n  agentSlaStatus = (agentHandleTimeSeconds <= slaLimitSeconds) ? \"Met\" : \"Missed\";\n}\n\nlet resolvedDuringOfficeHours = null;\nif (resolvedAt) {\n  const teamCode = getTeamCode(currentTeamName);\n  resolvedDuringOfficeHours = isWithinWorkingHours(resolvedAt, teamCode);\n}\n\nconst qualifies = isResolved && resolvedAfterStart;\n\nconst date = resolvedDateStr;\nconst uniqueId = `${date}|${ticketDisplayId}`;\n\nconst teamColumns = {};\nfor (const teamName of TRACKED_TEAMS) {\n  teamColumns[teamName] = teamsVisited.has(teamName) ? \"Yes\" : \"\";\n}\n\nreturn {\n  json: {\n    \"_filter_passed\": qualifies,\n    \"unique_id\": uniqueId,\n    \"date\": date,\n    \"ticket_id\": ticketDisplayId,\n    \"ticket_creator_agent_name\": creatorName,\n    \"ticket_handler_agent_name\": handlerName,\n    \"resolution_time\": resolutionTime,\n    \"agent_handle_time\": agentHandleTime,\n    \"ticket_status\": ticketStateLabel,\n    \"sla\": ticketSlaStatus,\n    \"sla_limit_hours\": slaLimitHours,\n    \"product_type\": productType,\n    \"resolved_during_office_hours\": resolvedDuringOfficeHours,\n    \"current_team\": currentTeamName,\n    \"issue_category\": issueCategory,\n    \"description_last_ticket_note\": lastAdminNoteText,\n    \"forwarded\": false,\n    \"forwarded_to\": \"\",\n    \"ticket_creator_email\": creatorEmail,\n    \"pro_solutions_task_force\": teamColumns[\"Pro Solutions Task Force\"],\n    \"cex_reversal\": teamColumns[\"CEx Reversal\"],\n    \"ticket_dependencies\": teamColumns[\"Ticket Dependencies\"],\n    \"payments_and_treasury\": teamColumns[\"Payments and Treasury\"],\n    \"gb_email_communication\": teamColumns[\"GB Email Communication\"],\n    \"tech_team\": teamColumns[\"Tech Team\"],\n    \"business_operations\": teamColumns[\"Business Operations\"],\n    \"platform_operations\": teamColumns[\"Platform Operations\"],\n    \"case_resolution\": teamColumns[\"Case Resolution\"],\n    \"ticket_sla_status\": ticketSlaStatus,\n    \"ticket_sla_limit_hours\": slaLimitHours,\n    \"ticket_sla_duration_seconds\": resolutionTimeSeconds,\n    \"agent_sla_status\": agentSlaStatus,\n    \"agent_handle_time_seconds\": agentHandleTimeSeconds\n  }\n};"
            },
            "id": "dae099ab-92d4-40c0-8405-73ccfd545f96",
            "name": "Transform Ticket Data1",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -2032,
                -416
            ]
        },
        {
            "parameters": {
                "rule": {
                    "interval": [
                        {
                            "field": "hours",
                            "hoursInterval": 2
                        }
                    ]
                }
            },
            "id": "9585eb8c-d586-455f-b4e6-bd1fcf146bb3",
            "name": "Schedule Trigger (Every 5 Minutes)",
            "type": "n8n-nodes-base.scheduleTrigger",
            "typeVersion": 1.2,
            "position": [
                -3776,
                -224
            ]
        },
        {
            "parameters": {
                "jsCode": "// Gate: Only process if we're past Jan 1, 2026 00:00:00 GMT+6\n// Jan 1, 2026 00:00:00 GMT+6 = Dec 31, 2025 18:00:00 UTC = 1767204000\nconst START_UNIX = 1767204000;\nconst nowUnix = Math.floor(Date.now() / 1000);\n\nif (nowUnix < START_UNIX) {\n  return [];\n}\n\nconst sd = $getWorkflowStaticData('global');\nif (typeof sd.last_sync !== 'number') sd.last_sync = START_UNIX;\n\nreturn [{\n  json: {\n    start_unix: START_UNIX,\n    now_unix: nowUnix,\n    last_sync: sd.last_sync\n  }\n}];\n"
            },
            "id": "0c3fc4a4-b219-4b64-b177-4075befc7e88",
            "name": "Gate: Start on 2026-01-",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -3552,
                -224
            ]
        },
        {
            "parameters": {
                "url": "https://api.intercom.io/teams",
                "authentication": "predefinedCredentialType",
                "nodeCredentialType": "httpBearerAuth",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Accept",
                            "value": "application/json"
                        },
                        {
                            "name": "Intercom-Version",
                            "value": "2.11"
                        }
                    ]
                },
                "options": {
                    "response": {}
                }
            },
            "id": "fccd8570-55ae-43d1-ab65-62e5428b8e74",
            "name": "List Teams",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.3,
            "position": [
                -3312,
                -224
            ],
            "credentials": {
                "httpBearerAuth": {
                    "id": "NP8zyf9bSfqaxMj0",
                    "name": "Bearer Auth account 3"
                }
            }
        },
        {
            "parameters": {
                "jsCode": "// Build team maps: id->name and name(lower)->id\n// STORE IN STATIC DATA so Transform Ticket Data can access without $() reference\n\nfunction ensureObj(x){\n  if (!x) return {};\n  if (typeof x === 'string'){\n    try { return JSON.parse(x); } catch { return {}; }\n  }\n  return x;\n}\n\nconst resp = ensureObj($json);\nconst teams = resp.teams || resp.data || [];\n\nconst idToName = {};\nconst nameToId = {};\n\nfor (const t of teams) {\n  if (!t || !t.id) continue;\n  const name = (t.name || '').trim();\n  idToName[t.id] = name;\n  if (name) nameToId[name.toLowerCase()] = t.id;\n}\n\n// Store in workflow static data for later access\nconst sd = $getWorkflowStaticData('global');\nsd.teamIdToName = idToName;\nsd.teamNameToId = nameToId;\n\nreturn [{\n  json: {\n    idToName,\n    nameToId\n  }\n}];\n"
            },
            "id": "4b9ef0c1-423d-4087-a15d-d0b3f62481a6",
            "name": "Build Team Map",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -3088,
                -224
            ]
        },
        {
            "parameters": {
                "jsCode": "// Build the Intercom /tickets/search request body.\n// Filter by RESOLVED STATUS + SPECIFIC TEAMS\n// Date range: Last 5 days to NOW\n// Sort: ascending (oldest first)\n\n// Dynamic: Calculate 5 days ago from now\nconst FIVE_DAYS_SECONDS = 5 * 24 * 60 * 60;\nconst NOW_UNIX = Math.floor(Date.now() / 1000);\nconst START_UNIX = NOW_UNIX - FIVE_DAYS_SECONDS;\n\n// TEAM IDs to filter by (10 teams total)\nconst TEAM_IDS = [\n  \"8314220\",  // Business Operations 1\n  \"9644821\",  // Business Operations 2\n  \"6681977\",  // Tech Team\n  \"6533520\",  // Platform Operations\n  \"6681962\",  // Payments and Treasury\n  \"6921111\",  // GB Email Communication\n  \"6547584\",  // Case Resolution\n  \"6682031\",  // Pro Solutions Task Force / Ticket Dependencies / CEx Reversal\n  \"6661069\",  // Pro Solutions Task Force / Ticket Dependencies / CEx Reversal\n  \"8009000\"   // Pro Solutions Task Force / Ticket Dependencies / CEx Reversal\n];\n\n// Build team filter conditions (OR)\nconst teamConditions = TEAM_IDS.map(id => ({\n  field: \"team_assignee_id\",\n  operator: \"=\",\n  value: id\n}));\n\n// State filter conditions (OR)\nconst stateConditions = [\n  { field: \"state\", operator: \"=\", value: \"resolved\" },\n  { field: \"state\", operator: \"=\", value: \"closed\" }\n];\n\n// Combined query: Last 5 days to now\nconst queryConditions = [\n  { field: \"updated_at\", operator: \">=\", value: START_UNIX },\n  { field: \"updated_at\", operator: \"<=\", value: NOW_UNIX },\n  { operator: \"OR\", value: stateConditions },\n  { operator: \"OR\", value: teamConditions }\n];\n\nreturn [{\n  json: {\n    body: {\n      query: {\n        operator: \"AND\",\n        value: queryConditions\n      },\n      pagination: {\n        per_page: 100\n      },\n      sort: {\n        field: \"updated_at\",\n        order: \"ascending\"\n      }\n    },\n    meta: {\n      start_unix: START_UNIX,\n      end_unix: NOW_UNIX,\n      mode: \"LAST_5_DAYS\",\n      teams: TEAM_IDS,\n      states: [\"resolved\", \"closed\"]\n    }\n  }\n}];"
            },
            "id": "e0dcfb05-4be8-4092-b819-aa974c1d8008",
            "name": "Build HTTP Body",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -2880,
                -224
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "https://api.intercom.io/tickets/search",
                "authentication": "predefinedCredentialType",
                "nodeCredentialType": "httpBearerAuth",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Content-Type",
                            "value": "application/json"
                        },
                        {
                            "name": "Intercom-Version",
                            "value": "2.11"
                        }
                    ]
                },
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ $json.body }}",
                "options": {
                    "response": {}
                }
            },
            "id": "1a232896-8b68-4206-8576-0a25f14ecd33",
            "name": "Search Tickets",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.3,
            "position": [
                -2672,
                -224
            ],
            "credentials": {
                "httpBearerAuth": {
                    "id": "3aJKqmWSz1EBLLuh",
                    "name": "Bearer Auth account 4"
                }
            }
        },
        {
            "parameters": {
                "jsCode": "// Extract tickets from Intercom's tickets array\n// Pre-filter tickets resolved before the last 5 days to save API calls\n\n// Dynamic: Calculate 5 days ago from now\nconst FIVE_DAYS_SECONDS = 5 * 24 * 60 * 60;\nconst NOW_UNIX = Math.floor(Date.now() / 1000);\nconst START_UNIX = NOW_UNIX - FIVE_DAYS_SECONDS;\n\nconst input = $json || {};\nconst tickets = input.tickets || [];\n\nconst results = [];\n\nfor (const ticket of tickets) {\n  const ticketId = ticket.id;\n  const stateUpdatedAt = ticket.state_updated_at || 0;\n  const state = (ticket.state || \"\").toLowerCase();\n  const isResolved = state === \"resolved\" || state === \"closed\";\n  \n  // Skip if resolved before the last 5 days (and we have the data)\n  if (isResolved && stateUpdatedAt > 0 && stateUpdatedAt < START_UNIX) {\n    continue;\n  }\n  \n  if (ticketId) {\n    results.push({\n      json: {\n        \"id\": String(ticketId),\n        \"ticket_id\": String(ticket.ticket_id || \"\"),\n        \"state\": ticket.state || \"\",\n        \"state_updated_at\": stateUpdatedAt,\n        \"team_assignee_id\": ticket.team_assignee_id || \"\"\n      }\n    });\n  }\n}\n\nreturn results;"
            },
            "id": "072a1a23-8bfe-4fdf-89f8-293f54e14d62",
            "name": "Extract Tickets1",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -2432,
                -416
            ]
        },
        {
            "parameters": {
                "url": "=https://api.intercom.io/tickets/{{$json[\"id\"]}}",
                "authentication": "predefinedCredentialType",
                "nodeCredentialType": "httpBearerAuth",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Content-Type",
                            "value": "application/json"
                        },
                        {
                            "name": "Intercom-Version",
                            "value": "2.11"
                        }
                    ]
                },
                "options": {
                    "response": {}
                }
            },
            "id": "d4e920c8-d1af-4c4d-9f56-faa66d96e46a",
            "name": "Get Ticket Details",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.3,
            "position": [
                -2224,
                -416
            ],
            "credentials": {
                "httpBearerAuth": {
                    "id": "Wb6mK3xsTXEujIUR",
                    "name": "Bearer Auth account 5"
                }
            },
            "onError": "continueRegularOutput"
        },
        {
            "parameters": {
                "conditions": {
                    "boolean": [
                        {
                            "value1": "={{ $json[\"_filter_passed\"] }}",
                            "value2": true
                        }
                    ]
                }
            },
            "id": "e80a3468-59e1-487e-ba72-67aaa65f62be",
            "name": "Filter Passed?",
            "type": "n8n-nodes-base.if",
            "typeVersion": 1,
            "position": [
                -1792,
                -416
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "https://umkzssfympyhifdjptwf.supabase.co/rest/v1/ticket_logs?on_conflict=unique_id",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Content-Type",
                            "value": "application/json"
                        },
                        {
                            "name": "Prefer",
                            "value": "resolution=merge-duplicates"
                        },
                        {
                            "name": "apikey",
                            "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVta3pzc2Z5bXB5aGlmZGpwdHdmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2Nzk1MzkzMywiZXhwIjoyMDgzNTI5OTMzfQ.uLp84D6LmkkEL5rGgIp-EOuUX_vhNc82n-oHm6qWW-0"
                        },
                        {
                            "name": "Authorization",
                            "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVta3pzc2Z5bXB5aGlmZGpwdHdmIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2Nzk1MzkzMywiZXhwIjoyMDgzNTI5OTMzfQ.uLp84D6LmkkEL5rGgIp-EOuUX_vhNc82n-oHm6qWW-0"
                        }
                    ]
                },
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ JSON.stringify({ unique_id: $json.unique_id, date: $json.date || null, ticket_id: $json.ticket_id, ticket_creator_agent_name: $json.ticket_creator_agent_name, ticket_handler_agent_name: $json.ticket_handler_agent_name, resolution_time: $json.resolution_time, agent_handle_time: $json.agent_handle_time, ticket_status: $json.ticket_status, sla: $json.sla, sla_limit_hours: $json.sla_limit_hours, product_type: $json.product_type, resolved_during_office_hours: $json.resolved_during_office_hours, current_team: $json.current_team, issue_category: $json.issue_category, description_last_ticket_note: $json.description_last_ticket_note, forwarded: $json.forwarded, forwarded_to: $json.forwarded_to, ticket_creator_email: $json.ticket_creator_email, pro_solutions_task_force: $json.pro_solutions_task_force, cex_reversal: $json.cex_reversal, ticket_dependencies: $json.ticket_dependencies, payments_and_treasury: $json.payments_and_treasury, gb_email_communication: $json.gb_email_communication, tech_team: $json.tech_team, business_operations: $json.business_operations, platform_operations: $json.platform_operations, case_resolution: $json.case_resolution, ticket_sla_status: $json.ticket_sla_status, ticket_sla_limit_hours: $json.ticket_sla_limit_hours, ticket_sla_duration_seconds: $json.ticket_sla_duration_seconds, agent_sla_status: $json.agent_sla_status, agent_handle_time_seconds: $json.agent_handle_time_seconds }) }}",
                "options": {}
            },
            "id": "07ebf563-570e-4982-bd82-f6f582a12651",
            "name": "Upsert to Supabase",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.3,
            "position": [
                -1456,
                -432
            ]
        },
        {
            "parameters": {
                "jsCode": "// Pagination handler - simple pagination without circuit breaker\n\nfunction clone(o) {\n  return JSON.parse(JSON.stringify(o));\n}\n\nfunction ensureObj(x) {\n  if (!x) return {};\n  if (typeof x === 'string') {\n    try { return JSON.parse(x); } catch { return {}; }\n  }\n  return x;\n}\n\nconst resp = ensureObj($json);\nconst pageNow = resp?.pages?.page ?? 1;\nconst nextCursor = resp?.pages?.next?.starting_after ?? null;\n\nconst baseBody = clone($(\"Build HTTP Body\").first().json.body);\nbaseBody.pagination = baseBody.pagination || {};\nbaseBody.pagination.per_page = 100;\nif (nextCursor) baseBody.pagination.starting_after = nextCursor;\nelse delete baseBody.pagination.starting_after;\n\nconst MAX_PAGES = 2000;\nconst hasNext = Boolean(nextCursor) && pageNow < MAX_PAGES;\n\nreturn [{\n  json: {\n    body: baseBody,\n    has_next: hasNext,\n    page_now: pageNow\n  }\n}];\n"
            },
            "id": "5e99e06e-5b15-4ae7-9b7b-c51cdfb97cf0",
            "name": "Paginate: Prepare next body",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -2432,
                -224
            ]
        },
        {
            "parameters": {},
            "id": "56e3db06-1292-4edf-91d8-cccee55d073c",
            "name": "Merge",
            "type": "n8n-nodes-base.merge",
            "typeVersion": 3.2,
            "position": [
                -2096,
                -176
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "options": {
                        "caseSensitive": true,
                        "leftValue": "",
                        "typeValidation": "strict",
                        "version": 2
                    },
                    "conditions": [
                        {
                            "id": "ef34f615-6b27-4dd4-8386-54f5cc41d193",
                            "leftValue": "={{ $json.has_next }}",
                            "rightValue": "",
                            "operator": {
                                "type": "boolean",
                                "operation": "true",
                                "singleValue": true
                            }
                        }
                    ],
                    "combinator": "and"
                },
                "options": {}
            },
            "id": "c0f63186-2622-48d2-b8d1-e7ee999c04d0",
            "name": "If (Has Next Page?)",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2.2,
            "position": [
                -1760,
                -176
            ]
        }
    ],
    "connections": {
        "Transform Ticket Data1": {
            "main": [
                [
                    {
                        "node": "Filter Passed?",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Schedule Trigger (Every 5 Minutes)": {
            "main": [
                [
                    {
                        "node": "Gate: Start on 2026-01-",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Gate: Start on 2026-01-": {
            "main": [
                [
                    {
                        "node": "List Teams",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "List Teams": {
            "main": [
                [
                    {
                        "node": "Build Team Map",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Build Team Map": {
            "main": [
                [
                    {
                        "node": "Build HTTP Body",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Build HTTP Body": {
            "main": [
                [
                    {
                        "node": "Search Tickets",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Search Tickets": {
            "main": [
                [
                    {
                        "node": "Paginate: Prepare next body",
                        "type": "main",
                        "index": 0
                    },
                    {
                        "node": "Extract Tickets1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Extract Tickets1": {
            "main": [
                [
                    {
                        "node": "Get Ticket Details",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Get Ticket Details": {
            "main": [
                [
                    {
                        "node": "Transform Ticket Data1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Filter Passed?": {
            "main": [
                [
                    {
                        "node": "Upsert to Supabase",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Merge",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Upsert to Supabase": {
            "main": [
                [
                    {
                        "node": "Merge",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Paginate: Prepare next body": {
            "main": [
                [
                    {
                        "node": "Merge",
                        "type": "main",
                        "index": 1
                    }
                ]
            ]
        },
        "Merge": {
            "main": [
                [
                    {
                        "node": "If (Has Next Page?)",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "If (Has Next Page?)": {
            "main": [
                [
                    {
                        "node": "Search Tickets",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "pinData": {},
    "meta": {
        "templateCredsSetupCompleted": true,
        "instanceId": "b076ee236eeb0f1e0d5cf68bfef91d2e6b976d3c37b7dea8eeb4131cf958e05f"
    }
}
